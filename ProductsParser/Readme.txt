
- Щоб запустити додаток потрібно виконати команду dotnet run або скористатися IDE

- Після запуску почнеться процес збору інформації

!ВАЖЛИВО!
В папці Global, для зручності, я помістив декілька констант, на які потрібно звернути увагу:
У мене браузер відкривається так, що сітка продуктів містить по 2 елементи в рядок, тому:
  public const int ItemsPerPage = 2;
  !якщо у вас більше, потірбно змінити, тому що для преходу на наст. сторінку потрібно проскролитись вниз!
Наступна константа:
  public const int ParseLimit = 3;
  означає, що буде зібрано інформації лише з 3 катерогій, там на сайті їх 60+,
  тому, для тестування, я обрав 3

!В програмі не відображається стан виконнаня, тому потрібно самому слідкувати за цим!



- Пояснення коду
Насправді, я не розумію, що саме ви маєте на увазі під "пояснення як він працює"
Потрібно додати коментарі до коду? Чи щось інше?

Тому розкажу про основні "компоненти" додатку:

1. Все, що наслідується від IDataStorage - це класи, що реалізують зберігання даних у відповідному форматі
На даний момент в проекті тільки один storage - це JsonDataStorage,
але в подальшому можна буде реалізовувати стораджи ось так:
DBDataStorage:IDataStorage, CSVDataStorage:IDataStorage, XMLDataStorage:IDataStorage

2. IExecutionStrategy - стратегія виконня додатку
В проекті є ExecutionWithoutUserInteractionStrategy, що призначений для виконання програми без втручання користувача
Також є ExecutionWithUserInteractionStrategy (не реалізований), в цьому класі я хотів написати подібну логіку:
2.1. Коли додаток запустився, попросити у користувача закрити всі вікна на сайті
2.2. Запитувати у користувача стан сторінки: завантажилась вона чи ні. Це потрібно для того, щоб не було випадків,
 коли сторіка ще не завантажилась, а програма вже починає шукати елементи
2.3. Ну і подібні речі, щоб уникати помилок роботи програми


3. IParsingTemplate - це шаблон по якому виконується парсинг.
Я написав свій шаблон, але сайт може оновитися або можуть змінитися класи у тегів, і тоді,
інший програміст напише свій темплейт і просто підставить його в додаток: NewTemplate:IParsingTemplate

4. IAppParserOption - базові залежності, які потрібні для роботи додатку

5. IOutPutHelper - інтерфейс, який мав би забезпечувати вивід інформації, наприклад: на консоль або показати текстбокс
Також хотів додати IInputHelper, але це потребує часу і є більш актуальні проблеми.
Ціль таких інтерфейсів - передача їх у додаток і робота додатку без прив'язки до конкретного інтерфейсу(консольний,інші)

- Залежності:
ProductsParserApp приймає веб-драйвер(вже сконфігурований!), сторадж для даних(IDataStorage)
 та шаблон парсингу (IParsingTemplate)
Такий підхід надасть змогу в подальшому підставляти будь-які парсери та стораджи і додаток буде працювати "не залежно від них"

ExecutionWithoutUserInteractionStrategy приймає сторадж та парсинг темплейт

ParsingByCategoriesTemplate приймає тільки веб драйвер

ТОБТО:
 1. ProductsParserApp оперує IExecutionStrategy,
 2. IExecutionStrategy оперує  IParsingTemplate та IDataStorage
 3. IParsingTemplate оперує IWebDriver

Тут, на даний момент, дуже важлива ієрархія, щоб компоненти працювали з одними і тими самими об'єктами, але
Далі можна винести деякі компоненти в State,  щоб ним вже оперували всі остальні (і відповідно, щоб він був у всіх один)


Також я ще не рефакторив код, тому там може не вистачати обробки помилок, декомпозиції та іншого
Також я хотів додати категорію до продукту, але на це також потрібно парсити, тому можливо це зайве
Також, якщо ціна продукту 0 - це означає, що його немає в наявності (також потрібно в модель додати опис, що продукт відсутній)


- Алгорим роботи додатку (пояснення як працює додаток):
1. Перейти на сторінку з категоріями товарів
1.1. Зібрати посилання з цих катерогій (href атрибут)
1.2. Переходити по зібраним посиланням до тих пір, поки вони не закінчаться або ітерація  не стане рівної константі ParseLimit
1.3. Перейшовши за посиланням
    1.3.1. Якщо сторінка містить в собі інші категорії - додати їх у список посилань і перейти до наст. ітерації
    1.3.2. Інакше зібрати інформацію  про продукти поточної категорії
1.4. Зібравши інформацію - зберегти її в json файл
1.5. Завершити програму, коли буде натиснуто будь-яку кнопку на клавіатурі

